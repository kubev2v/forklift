// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Flexcache Defines the cache endpoint of FlexCache.
//
// swagger:model flexcache
type Flexcache struct {

	// links
	Links *FlexcacheInlineLinks `json:"_links,omitempty"`

	// Number of FlexCache constituents per aggregate when the 'aggregates' field is mentioned.
	ConstituentsPerAggregate *int64 `json:"constituents_per_aggregate,omitempty"`

	// If set to true, a DR cache is created.
	DrCache *bool `json:"dr_cache,omitempty"`

	// flexcache inline aggregates
	FlexcacheInlineAggregates []*FlexcacheInlineAggregatesInlineArrayItem `json:"aggregates,omitempty"`

	// flexcache inline origins
	FlexcacheInlineOrigins []*FlexcacheRelationship `json:"origins,omitempty"`

	// Specifies whether or not a FlexCache volume has global file locking mode enabled. Global file locking mode is a mode where protocol read locking semantics are enforced across all FlexCaches and origins of a FlexCache volume. When global file locking mode is enabled, the "is_disconnected_mode_off_for_locks" flag is always set to "true".
	GlobalFileLockingEnabled *bool `json:"global_file_locking_enabled,omitempty"`

	// guarantee
	Guarantee *FlexcacheInlineGuarantee `json:"guarantee,omitempty"`

	// FlexCache name
	// Example: vol1
	// Max Length: 203
	// Min Length: 1
	Name *string `json:"name,omitempty"`

	// The fully-qualified path in the owning SVM's namespace at which the FlexCache is mounted. The path is case insensitive and must be unique within a SVM's namespace. Path must begin with '/' and must not end with '/'. Only one FlexCache be mounted at any given junction path.
	// Example: /user/my_fc
	Path *string `json:"path,omitempty"`

	// prepopulate
	Prepopulate *FlexcacheInlinePrepopulate `json:"prepopulate,omitempty"`

	// Physical size of the FlexCache. The recommended size for a FlexCache is 10% of the origin volume. The minimum FlexCache constituent size is 1GB.
	Size *int64 `json:"size,omitempty"`

	// svm
	Svm *FlexcacheInlineSvm `json:"svm,omitempty"`

	// Specifies whether or not a Fabricpool-enabled aggregate can be used in FlexCache creation. The use_tiered_aggregate is only used when auto-provisioning a FlexCache volume.
	UseTieredAggregate *bool `json:"use_tiered_aggregate,omitempty"`

	// FlexCache UUID. Unique identifier for the FlexCache.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`

	// writeback
	Writeback *FlexcacheInlineWriteback `json:"writeback,omitempty"`
}

// Validate validates this flexcache
func (m *Flexcache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcacheInlineAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcacheInlineOrigins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrepopulate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWriteback(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Flexcache) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) validateFlexcacheInlineAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.FlexcacheInlineAggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.FlexcacheInlineAggregates); i++ {
		if swag.IsZero(m.FlexcacheInlineAggregates[i]) { // not required
			continue
		}

		if m.FlexcacheInlineAggregates[i] != nil {
			if err := m.FlexcacheInlineAggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Flexcache) validateFlexcacheInlineOrigins(formats strfmt.Registry) error {
	if swag.IsZero(m.FlexcacheInlineOrigins) { // not required
		return nil
	}

	for i := 0; i < len(m.FlexcacheInlineOrigins); i++ {
		if swag.IsZero(m.FlexcacheInlineOrigins[i]) { // not required
			continue
		}

		if m.FlexcacheInlineOrigins[i] != nil {
			if err := m.FlexcacheInlineOrigins[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("origins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Flexcache) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *Flexcache) validatePrepopulate(formats strfmt.Registry) error {
	if swag.IsZero(m.Prepopulate) { // not required
		return nil
	}

	if m.Prepopulate != nil {
		if err := m.Prepopulate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prepopulate")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) validateWriteback(formats strfmt.Registry) error {
	if swag.IsZero(m.Writeback) { // not required
		return nil
	}

	if m.Writeback != nil {
		if err := m.Writeback.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("writeback")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache based on the context it is used
func (m *Flexcache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcacheInlineAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcacheInlineOrigins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrepopulate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWriteback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Flexcache) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) contextValidateFlexcacheInlineAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FlexcacheInlineAggregates); i++ {

		if m.FlexcacheInlineAggregates[i] != nil {
			if err := m.FlexcacheInlineAggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Flexcache) contextValidateFlexcacheInlineOrigins(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FlexcacheInlineOrigins); i++ {

		if m.FlexcacheInlineOrigins[i] != nil {
			if err := m.FlexcacheInlineOrigins[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("origins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Flexcache) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) contextValidatePrepopulate(ctx context.Context, formats strfmt.Registry) error {

	if m.Prepopulate != nil {
		if err := m.Prepopulate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prepopulate")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Flexcache) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

func (m *Flexcache) contextValidateWriteback(ctx context.Context, formats strfmt.Registry) error {

	if m.Writeback != nil {
		if err := m.Writeback.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("writeback")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Flexcache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Flexcache) UnmarshalBinary(b []byte) error {
	var res Flexcache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineAggregatesInlineArrayItem flexcache inline aggregates inline array item
//
// swagger:model flexcache_inline_aggregates_inline_array_item
type FlexcacheInlineAggregatesInlineArrayItem struct {

	// links
	Links *FlexcacheInlineAggregatesInlineArrayItemInlineLinks `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name *string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this flexcache inline aggregates inline array item
func (m *FlexcacheInlineAggregatesInlineArrayItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineAggregatesInlineArrayItem) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache inline aggregates inline array item based on the context it is used
func (m *FlexcacheInlineAggregatesInlineArrayItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineAggregatesInlineArrayItem) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineAggregatesInlineArrayItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineAggregatesInlineArrayItem) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineAggregatesInlineArrayItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineAggregatesInlineArrayItemInlineLinks flexcache inline aggregates inline array item inline links
//
// swagger:model flexcache_inline_aggregates_inline_array_item_inline__links
type FlexcacheInlineAggregatesInlineArrayItemInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this flexcache inline aggregates inline array item inline links
func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache inline aggregates inline array item inline links based on the context it is used
func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineAggregatesInlineArrayItemInlineLinks) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineAggregatesInlineArrayItemInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineGuarantee flexcache inline guarantee
//
// swagger:model flexcache_inline_guarantee
type FlexcacheInlineGuarantee struct {

	// The type of space guarantee of this volume in the aggregate.
	// Enum: [volume none]
	Type *string `json:"type,omitempty"`
}

// Validate validates this flexcache inline guarantee
func (m *FlexcacheInlineGuarantee) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var flexcacheInlineGuaranteeTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["volume","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		flexcacheInlineGuaranteeTypeTypePropEnum = append(flexcacheInlineGuaranteeTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// flexcache_inline_guarantee
	// FlexcacheInlineGuarantee
	// type
	// Type
	// volume
	// END DEBUGGING
	// FlexcacheInlineGuaranteeTypeVolume captures enum value "volume"
	FlexcacheInlineGuaranteeTypeVolume string = "volume"

	// BEGIN DEBUGGING
	// flexcache_inline_guarantee
	// FlexcacheInlineGuarantee
	// type
	// Type
	// none
	// END DEBUGGING
	// FlexcacheInlineGuaranteeTypeNone captures enum value "none"
	FlexcacheInlineGuaranteeTypeNone string = "none"
)

// prop value enum
func (m *FlexcacheInlineGuarantee) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, flexcacheInlineGuaranteeTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FlexcacheInlineGuarantee) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("guarantee"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this flexcache inline guarantee based on context it is used
func (m *FlexcacheInlineGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineGuarantee) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineLinks flexcache inline links
//
// swagger:model flexcache_inline__links
type FlexcacheInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this flexcache inline links
func (m *FlexcacheInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache inline links based on the context it is used
func (m *FlexcacheInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineLinks) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlinePrepopulate FlexCache prepopulate
//
// swagger:model flexcache_inline_prepopulate
type FlexcacheInlinePrepopulate struct {

	// dir paths
	DirPaths []*string `json:"dir_paths,omitempty"`

	// exclude dir paths
	ExcludeDirPaths []*string `json:"exclude_dir_paths,omitempty"`

	// Specifies whether or not the prepopulate action should search through the `dir_paths` recursively. If not set, the default value _true_ is used.
	Recurse *bool `json:"recurse,omitempty"`
}

// Validate validates this flexcache inline prepopulate
func (m *FlexcacheInlinePrepopulate) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this flexcache inline prepopulate based on context it is used
func (m *FlexcacheInlinePrepopulate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlinePrepopulate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlinePrepopulate) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlinePrepopulate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineSvm FlexCache SVM
//
// swagger:model flexcache_inline_svm
type FlexcacheInlineSvm struct {

	// links
	Links *FlexcacheInlineSvmInlineLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name *string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this flexcache inline svm
func (m *FlexcacheInlineSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache inline svm based on the context it is used
func (m *FlexcacheInlineSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineSvm) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineSvmInlineLinks flexcache inline svm inline links
//
// swagger:model flexcache_inline_svm_inline__links
type FlexcacheInlineSvmInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this flexcache inline svm inline links
func (m *FlexcacheInlineSvmInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineSvmInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this flexcache inline svm inline links based on the context it is used
func (m *FlexcacheInlineSvmInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlexcacheInlineSvmInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineSvmInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineSvmInlineLinks) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineSvmInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FlexcacheInlineWriteback FlexCache Writeback
//
// swagger:model flexcache_inline_writeback
type FlexcacheInlineWriteback struct {

	// Indicates whether or not writeback is enabled for the FlexCache volume. Writeback is a storage method where data is first written to the FlexCache volume and then written to the origin of a FlexCache volume.
	Enabled *bool `json:"enabled,omitempty"`

	// Specifies the amount of data in 4KB blocks that the system can write per inode in a FlexCache volume before a writeback is initiated for that inode. This property is only relevant to a FlexCache Volume with the writeback property enabled.
	PerInodeDirtyLimit *int64 `json:"per_inode_dirty_limit,omitempty"`

	// Specifies the threshold value in 4KB data blocks which when hit will trigger a scrub that will initiate writeback for all dirty inodes on the FlexCache volume. This property is only relevant to a FlexCache Volume with the writeback property enabled.
	ScrubThreshold *int64 `json:"scrub_threshold,omitempty"`

	// Specifies the maximum number of 4KB data blocks the system can transfer, at one time, from the cache to the origin. This process will keep on recurring until all the dirty blocks for the inode are transferred to the origin volume. This property is only relevant to a FlexCache Volume with the writeback property enabled.
	TransferLimit *int64 `json:"transfer_limit,omitempty"`
}

// Validate validates this flexcache inline writeback
func (m *FlexcacheInlineWriteback) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this flexcache inline writeback based on context it is used
func (m *FlexcacheInlineWriteback) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FlexcacheInlineWriteback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlexcacheInlineWriteback) UnmarshalBinary(b []byte) error {
	var res FlexcacheInlineWriteback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
