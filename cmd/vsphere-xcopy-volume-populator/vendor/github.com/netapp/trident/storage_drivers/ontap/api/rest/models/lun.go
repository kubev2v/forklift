// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Lun A LUN is the logical representation of storage in a storage area network (SAN).<br/>
// In ONTAP, a LUN is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// A LUN can be created to a specified size using thin or thick provisioning. A LUN can then be renamed, resized, cloned, and moved to a different volume. LUNs support the assignment of a quality of service (QoS) policy for performance management or a QoS policy can be assigned to the volume containing the LUN. See the LUN object model to learn more about each of the properties supported by the LUN REST API.<br/>
// A LUN must be mapped to an initiator group to grant access to the initiator group's initiators (client hosts). Initiators can then access the LUN and perform I/O over a Fibre Channel (FC) fabric using the Fibre Channel Protocol or a TCP/IP network using iSCSI.
//
// swagger:model lun
type Lun struct {

	// links
	Links *LunInlineLinks `json:"_links,omitempty"`

	// This property marks the LUN for auto deletion when the volume containing the LUN runs out of space. This is most commonly set on LUN clones.<br/>
	// When set to _true_, the LUN becomes eligible for automatic deletion when the volume runs out of space. Auto deletion only occurs when the volume containing the LUN is also configured for auto deletion and free space in the volume decreases below a particular threshold.<br/>
	// This property is optional in POST and PATCH. The default value for a new LUN is _false_.<br/>
	// There is an added computational cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The class of LUN.<br/>
	// Optional in POST.
	//
	// Enum: [regular protocol_endpoint vvol]
	Class *string `json:"class,omitempty"`

	// clone
	Clone *LunInlineClone `json:"clone,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// consistency group
	ConsistencyGroup *LunInlineConsistencyGroup `json:"consistency_group,omitempty"`

	// convert
	Convert *LunInlineConvert `json:"convert,omitempty"`

	// copy
	Copy *LunInlineCopy `json:"copy,omitempty"`

	// The time the LUN was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the LUN. LUNs can be disabled to prevent access to the LUN. Certain error conditions also cause the LUN to become disabled. If the LUN is disabled, you can consult the `state` property to determine if the LUN is administratively disabled (_offline_) or has become disabled as a result of an error. A LUN in an error condition can be brought online by setting the `enabled` property to _true_ or brought administratively offline by setting the `enabled` property to _false_. Upon creation, a LUN is enabled by default. Valid in PATCH.
	//
	Enabled *bool `json:"enabled,omitempty"`

	// location
	Location *LunInlineLocation `json:"location,omitempty"`

	// An array of name/value pairs optionally stored with the LUN. Attributes are available to callers to persist small amounts of application-specific metadata. They are in no way interpreted by ONTAP.<br/>
	// Attribute names and values must be at least one byte and no more than 4091 bytes in length. The sum of the name and value lengths must be no more than 4092 bytes.<br/>
	// Valid in POST except when creating a LUN clone. A cloned can already have attributes from its source. You can add, modify, and delete the attributes of a LUN clone in separate requests after creation of the LUN.<br/>
	// Attributes may be added/modified/removed for an existing LUN using the /api/storage/luns/{lun.uuid}/attributes endpoint. For further information, see [`DOC /storage/luns/{lun.uuid}/attributes`](#docs-SAN-storage_luns_{lun.uuid}_attributes).<br/>
	// There is an added computational cost to retrieving property values for `attributes`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	LunInlineAttributes []*LunInlineAttributesInlineArrayItem `json:"attributes,omitempty"`

	// The LUN maps with which the LUN is associated.<br/>
	// There is an added computational cost to retrieving property values for `lun_maps`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	LunInlineLunMaps []*LunInlineLunMapsInlineArrayItem `json:"lun_maps,omitempty"`

	// metric
	Metric *LunInlineMetric `json:"metric,omitempty"`

	// movement
	Movement *LunInlineMovement `json:"movement,omitempty"`

	// The fully qualified path name of the LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.<br/>
	// A PATCH that modifies the qtree and/or base name portion of the LUN path is considered a rename operation.<br/>
	// A PATCH that modifies the volume portion of the LUN path begins an asynchronous LUN movement operation.
	//
	// Example: /vol/volume1/qtree1/lun1
	Name *string `json:"name,omitempty"`

	// The operating system type of the LUN.<br/>
	// Required in POST when creating a LUN that is not a clone of another. Disallowed in POST when creating a LUN clone.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris solaris_efi vmware windows windows_2008 windows_gpt xen]
	OsType *string `json:"os_type,omitempty"`

	// qos policy
	QosPolicy *LunInlineQosPolicy `json:"qos_policy,omitempty"`

	// The LUN serial number. The serial number is generated by ONTAP when the LUN is created.
	//
	// Read Only: true
	// Max Length: 12
	// Min Length: 12
	SerialNumber *string `json:"serial_number,omitempty"`

	// space
	Space *LunInlineSpace `json:"space,omitempty"`

	// statistics
	Statistics *LunInlineStatistics `json:"statistics,omitempty"`

	// status
	Status *LunInlineStatus `json:"status,omitempty"`

	// svm
	Svm *LunInlineSvm `json:"svm,omitempty"`

	// The unique identifier of the LUN.  The UUID is generated by ONTAP when the LUN is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`

	// vvol
	Vvol *LunInlineVvol `json:"vvol,omitempty"`
}

// Validate validates this lun
func (m *Lun) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConvert(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCopy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLunInlineAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLunInlineLunMaps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQosPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVvol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Lun) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var lunTypeClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["regular","protocol_endpoint","vvol"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunTypeClassPropEnum = append(lunTypeClassPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// regular
	// END DEBUGGING
	// LunClassRegular captures enum value "regular"
	LunClassRegular string = "regular"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// protocol_endpoint
	// END DEBUGGING
	// LunClassProtocolEndpoint captures enum value "protocol_endpoint"
	LunClassProtocolEndpoint string = "protocol_endpoint"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// vvol
	// END DEBUGGING
	// LunClassVvol captures enum value "vvol"
	LunClassVvol string = "vvol"
)

// prop value enum
func (m *Lun) validateClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunTypeClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Lun) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(m.Class) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassEnum("class", "body", *m.Class); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateClone(formats strfmt.Registry) error {
	if swag.IsZero(m.Clone) { // not required
		return nil
	}

	if m.Clone != nil {
		if err := m.Clone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateConsistencyGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroup) { // not required
		return nil
	}

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateConvert(formats strfmt.Registry) error {
	if swag.IsZero(m.Convert) { // not required
		return nil
	}

	if m.Convert != nil {
		if err := m.Convert.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("convert")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateCopy(formats strfmt.Registry) error {
	if swag.IsZero(m.Copy) { // not required
		return nil
	}

	if m.Copy != nil {
		if err := m.Copy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateLunInlineAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.LunInlineAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.LunInlineAttributes); i++ {
		if swag.IsZero(m.LunInlineAttributes[i]) { // not required
			continue
		}

		if m.LunInlineAttributes[i] != nil {
			if err := m.LunInlineAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) validateLunInlineLunMaps(formats strfmt.Registry) error {
	if swag.IsZero(m.LunInlineLunMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.LunInlineLunMaps); i++ {
		if swag.IsZero(m.LunInlineLunMaps[i]) { // not required
			continue
		}

		if m.LunInlineLunMaps[i] != nil {
			if err := m.LunInlineLunMaps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateMovement(formats strfmt.Registry) error {
	if swag.IsZero(m.Movement) { // not required
		return nil
	}

	if m.Movement != nil {
		if err := m.Movement.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

var lunTypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","solaris_efi","vmware","windows","windows_2008","windows_gpt","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunTypeOsTypePropEnum = append(lunTypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// LunOsTypeAix captures enum value "aix"
	LunOsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// LunOsTypeHpux captures enum value "hpux"
	LunOsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// LunOsTypeHyperv captures enum value "hyper_v"
	LunOsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// LunOsTypeLinux captures enum value "linux"
	LunOsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// LunOsTypeNetware captures enum value "netware"
	LunOsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// LunOsTypeOpenvms captures enum value "openvms"
	LunOsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// LunOsTypeSolaris captures enum value "solaris"
	LunOsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// solaris_efi
	// END DEBUGGING
	// LunOsTypeSolarisEfi captures enum value "solaris_efi"
	LunOsTypeSolarisEfi string = "solaris_efi"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// LunOsTypeVmware captures enum value "vmware"
	LunOsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// LunOsTypeWindows captures enum value "windows"
	LunOsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows_2008
	// END DEBUGGING
	// LunOsTypeWindows2008 captures enum value "windows_2008"
	LunOsTypeWindows2008 string = "windows_2008"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows_gpt
	// END DEBUGGING
	// LunOsTypeWindowsGpt captures enum value "windows_gpt"
	LunOsTypeWindowsGpt string = "windows_gpt"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// LunOsTypeXen captures enum value "xen"
	LunOsTypeXen string = "xen"
)

// prop value enum
func (m *Lun) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunTypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Lun) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", *m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateQosPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.QosPolicy) { // not required
		return nil
	}

	if m.QosPolicy != nil {
		if err := m.QosPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.SerialNumber) { // not required
		return nil
	}

	if err := validate.MinLength("serial_number", "body", *m.SerialNumber, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("serial_number", "body", *m.SerialNumber, 12); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateVvol(formats strfmt.Registry) error {
	if swag.IsZero(m.Vvol) { // not required
		return nil
	}

	if m.Vvol != nil {
		if err := m.Vvol.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vvol")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun based on the context it is used
func (m *Lun) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConvert(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCopy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLunInlineAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLunInlineLunMaps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMovement(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQosPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVvol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Lun) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateClone(ctx context.Context, formats strfmt.Registry) error {

	if m.Clone != nil {
		if err := m.Clone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateConsistencyGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateConvert(ctx context.Context, formats strfmt.Registry) error {

	if m.Convert != nil {
		if err := m.Convert.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("convert")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateCopy(ctx context.Context, formats strfmt.Registry) error {

	if m.Copy != nil {
		if err := m.Copy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateLunInlineAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LunInlineAttributes); i++ {

		if m.LunInlineAttributes[i] != nil {
			if err := m.LunInlineAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) contextValidateLunInlineLunMaps(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lun_maps", "body", []*LunInlineLunMapsInlineArrayItem(m.LunInlineLunMaps)); err != nil {
		return err
	}

	for i := 0; i < len(m.LunInlineLunMaps); i++ {

		if m.LunInlineLunMaps[i] != nil {
			if err := m.LunInlineLunMaps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateMovement(ctx context.Context, formats strfmt.Registry) error {

	if m.Movement != nil {
		if err := m.Movement.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateQosPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.QosPolicy != nil {
		if err := m.QosPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", m.SerialNumber); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateVvol(ctx context.Context, formats strfmt.Registry) error {

	if m.Vvol != nil {
		if err := m.Vvol.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vvol")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Lun) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Lun) UnmarshalBinary(b []byte) error {
	var res Lun
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineAttributesInlineArrayItem A name/value pair optionally stored with the LUN. Attributes are available to callers to persist small amounts of application-specific metadata. They are in no way interpreted by ONTAP.<br/>
// Attribute names and values must be at least one byte and no more than 4091 bytes in length. The sum of the name and value lengths must be no more than 4092 bytes.<br/>
// Optional in POST.
//
// swagger:model lun_inline_attributes_inline_array_item
type LunInlineAttributesInlineArrayItem struct {

	// links
	Links *LunInlineAttributesInlineArrayItemInlineLinks `json:"_links,omitempty"`

	// The attribute name.
	//
	// Example: name1
	// Max Length: 4091
	// Min Length: 1
	Name *string `json:"name,omitempty"`

	// The attribute value.
	//
	// Example: value1
	// Max Length: 4091
	// Min Length: 1
	Value *string `json:"value,omitempty"`
}

// Validate validates this lun inline attributes inline array item
func (m *LunInlineAttributesInlineArrayItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineAttributesInlineArrayItem) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineAttributesInlineArrayItem) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 4091); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineAttributesInlineArrayItem) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(m.Value) { // not required
		return nil
	}

	if err := validate.MinLength("value", "body", *m.Value, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("value", "body", *m.Value, 4091); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline attributes inline array item based on the context it is used
func (m *LunInlineAttributesInlineArrayItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineAttributesInlineArrayItem) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineAttributesInlineArrayItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineAttributesInlineArrayItem) UnmarshalBinary(b []byte) error {
	var res LunInlineAttributesInlineArrayItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineAttributesInlineArrayItemInlineLinks lun inline attributes inline array item inline links
//
// swagger:model lun_inline_attributes_inline_array_item_inline__links
type LunInlineAttributesInlineArrayItemInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline attributes inline array item inline links
func (m *LunInlineAttributesInlineArrayItemInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineAttributesInlineArrayItemInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline attributes inline array item inline links based on the context it is used
func (m *LunInlineAttributesInlineArrayItemInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineAttributesInlineArrayItemInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineAttributesInlineArrayItemInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineAttributesInlineArrayItemInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineAttributesInlineArrayItemInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineClone This sub-object is used in POST to create a new LUN as a clone of an existing LUN, or PATCH to overwrite an existing LUN as a clone of another. Setting a property in this sub-object indicates that a LUN clone is desired. Consider the following other properties when cloning a LUN: `auto_delete`, `qos_policy`, `space.guarantee.requested` and `space.scsi_thin_provisioning_support_enabled`.<br/>
// When used in a PATCH, the patched LUN's data is over-written as a clone of the source and the following properties are preserved from the patched LUN unless otherwise specified as part of the PATCH: `class`, `auto_delete`, `lun_maps`, `serial_number`, `status.state`, and `uuid`.<br/>
// Persistent reservations for the patched LUN are also preserved.
//
// swagger:model lun_inline_clone
type LunInlineClone struct {

	// source
	Source *LunInlineCloneInlineSource `json:"source,omitempty"`
}

// Validate validates this lun inline clone
func (m *LunInlineClone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineClone) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline clone based on the context it is used
func (m *LunInlineClone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineClone) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineClone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineClone) UnmarshalBinary(b []byte) error {
	var res LunInlineClone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineCloneInlineSource The source LUN for a LUN clone operation. This can be specified using property `clone.source.uuid` or `clone.source.name`. If both properties are supplied, they must refer to the same LUN.<br/>
// Valid in POST to create a new LUN as a clone of the source.<br/>
// Valid in PATCH to overwrite an existing LUN's data as a clone of another.
//
// swagger:model lun_inline_clone_inline_source
type LunInlineCloneInlineSource struct {

	// The fully qualified path name of the clone source LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name *string `json:"name,omitempty"`

	// The unique identifier of the clone source LUN. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline clone inline source
func (m *LunInlineCloneInlineSource) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this lun inline clone inline source based on context it is used
func (m *LunInlineCloneInlineSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineCloneInlineSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineCloneInlineSource) UnmarshalBinary(b []byte) error {
	var res LunInlineCloneInlineSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineConsistencyGroup The LUN's consistency group. This property is populated for LUNs whose volume is a member of a consistency group. If the volume is a member of a child consistency group, the parent consistency group is reported.
//
// swagger:model lun_inline_consistency_group
type LunInlineConsistencyGroup struct {

	// links
	Links *LunInlineConsistencyGroupInlineLinks `json:"_links,omitempty"`

	// The name of the consistency group.
	//
	// Example: cg1
	// Read Only: true
	Name *string `json:"name,omitempty"`

	// The unique identifier of the consistency group.
	//
	// Example: 4abc2317-4332-9d37-93a0-20bd29c22df0
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline consistency group
func (m *LunInlineConsistencyGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConsistencyGroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline consistency group based on the context it is used
func (m *LunInlineConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConsistencyGroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineConsistencyGroup) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "consistency_group"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineConsistencyGroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "consistency_group"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res LunInlineConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineConsistencyGroupInlineLinks lun inline consistency group inline links
//
// swagger:model lun_inline_consistency_group_inline__links
type LunInlineConsistencyGroupInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline consistency group inline links
func (m *LunInlineConsistencyGroupInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConsistencyGroupInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline consistency group inline links based on the context it is used
func (m *LunInlineConsistencyGroupInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConsistencyGroupInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineConsistencyGroupInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineConsistencyGroupInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineConsistencyGroupInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineConvert This sub-object is used in POST to convert a valid in-place NVMe namespace to a LUN. Setting a property in this sub-object indicates that a conversion from the specified NVMe namespace to LUN is desired.<br/>
//
// swagger:model lun_inline_convert
type LunInlineConvert struct {

	// namespace
	Namespace *LunInlineConvertInlineNamespace `json:"namespace,omitempty"`
}

// Validate validates this lun inline convert
func (m *LunInlineConvert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConvert) validateNamespace(formats strfmt.Registry) error {
	if swag.IsZero(m.Namespace) { // not required
		return nil
	}

	if m.Namespace != nil {
		if err := m.Namespace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("convert" + "." + "namespace")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline convert based on the context it is used
func (m *LunInlineConvert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNamespace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineConvert) contextValidateNamespace(ctx context.Context, formats strfmt.Registry) error {

	if m.Namespace != nil {
		if err := m.Namespace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("convert" + "." + "namespace")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineConvert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineConvert) UnmarshalBinary(b []byte) error {
	var res LunInlineConvert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineConvertInlineNamespace The source namespace for convert operation. This can be specified using property `convert.namespace.uuid` or `convert.namespace.name`. If both properties are supplied, they must refer to the same NVMe namespace.<br/>
// Valid in POST. A convert request from NVMe namespace to LUN cannot be combined with setting any other LUN properties. All other properties of the converted LUN comes from the source NVMe namespace.<br/>
//
// swagger:model lun_inline_convert_inline_namespace
type LunInlineConvertInlineNamespace struct {

	// The fully qualified path name of the source NVMe namespace composed of a "/vol" prefix, the volume name, the (optional) qtree name and base name of the NVMe namespace. Valid in POST.
	//
	// Example: /vol/volume1/namespace1
	Name *string `json:"name,omitempty"`

	// The unique identifier of the source NVMe namespace. Valid in POST.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline convert inline namespace
func (m *LunInlineConvertInlineNamespace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this lun inline convert inline namespace based on context it is used
func (m *LunInlineConvertInlineNamespace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineConvertInlineNamespace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineConvertInlineNamespace) UnmarshalBinary(b []byte) error {
	var res LunInlineConvertInlineNamespace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineCopy This sub-object applies to LUN copy operations. A LUN can be copied with a POST request that supplies `copy.source` properties.<br/>
// Copying a LUN is an asynchronous activity begun by a POST request that specifies the source of the copy in the `copy.source` properties. The data for the LUN is then asynchronously copied from the source to the destination. The time required to complete the copy depends on the size of the LUN and the load on the cluster. The `copy` sub-object is populated while a LUN copy is in progress and for two (2) minutes following completion of a copy.<br/>
// While LUNs are being copied, the status of the LUN copy operations can be obtained using a GET of the source or destination LUN that requests the `copy` properties. If the LUN is the source LUN for one or more copy operations, the `copy.destinations` array is populated in GET. If the containing LUN is the destination LUN for a copy operation, the `copy.source` sub-object is populated in GET. The LUN copy operation can be further modified using a PATCH on the properties on the `copy.source` sub-object of the copy destination LUN.<br/>
// There is an added computational cost to retrieving property values for `copy`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
// swagger:model lun_inline_copy
type LunInlineCopy struct {

	// An array of destination LUNs of LUN copy operations in which the containing LUN is the source of the copy.
	//
	// Read Only: true
	Destinations []*LunCopyDestinationsItems0 `json:"destinations,omitempty"`

	// source
	Source *LunInlineCopyInlineSource `json:"source,omitempty"`
}

// Validate validates this lun inline copy
func (m *LunInlineCopy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestinations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopy) validateDestinations(formats strfmt.Registry) error {
	if swag.IsZero(m.Destinations) { // not required
		return nil
	}

	for i := 0; i < len(m.Destinations); i++ {
		if swag.IsZero(m.Destinations[i]) { // not required
			continue
		}

		if m.Destinations[i] != nil {
			if err := m.Destinations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copy" + "." + "destinations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunInlineCopy) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline copy based on the context it is used
func (m *LunInlineCopy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestinations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopy) contextValidateDestinations(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"destinations", "body", []*LunCopyDestinationsItems0(m.Destinations)); err != nil {
		return err
	}

	for i := 0; i < len(m.Destinations); i++ {

		if m.Destinations[i] != nil {
			if err := m.Destinations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copy" + "." + "destinations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunInlineCopy) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineCopy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineCopy) UnmarshalBinary(b []byte) error {
	var res LunInlineCopy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0 A LUN copy operation in which the containing LUN is the source of the copy.
//
// swagger:model LunCopyDestinationsItems0
type LunCopyDestinationsItems0 struct {

	// links
	Links *LunCopyDestinationsItems0Links `json:"_links,omitempty"`

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN copy. See property `copy.source.max_throughput` for further details.
	//
	// Read Only: true
	MaxThroughput *int64 `json:"max_throughput,omitempty"`

	// The fully qualified path of the LUN copy destination composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Name *string `json:"name,omitempty"`

	// progress
	Progress *LunCopyDestinationsItems0Progress `json:"progress,omitempty"`

	// The unique identifier of the LUN copy destination.
	//
	// Example: 1bc327d5-4654-5284-a116-f182282240b4
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun copy destinations items0
func (m *LunCopyDestinationsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 based on the context it is used
func (m *LunCopyDestinationsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateMaxThroughput(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "max_throughput", "body", m.MaxThroughput); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0Links lun copy destinations items0 links
//
// swagger:model LunCopyDestinationsItems0Links
type LunCopyDestinationsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun copy destinations items0 links
func (m *LunCopyDestinationsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 links based on the context it is used
func (m *LunCopyDestinationsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Links) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0Progress Properties related to the progress of an active or recently completed LUN copy.
//
// swagger:model LunCopyDestinationsItems0Progress
type LunCopyDestinationsItems0Progress struct {

	// The amount of time that has elapsed since the start of the LUN copy, in seconds.
	//
	// Read Only: true
	Elapsed *int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN copy operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN copy.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete *int64 `json:"percent_complete,omitempty"`

	// The state of the LUN copy.
	//
	// Read Only: true
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State *string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN copy. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN copy.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun copy destinations items0 progress
func (m *LunCopyDestinationsItems0Progress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("progress"+"."+"percent_complete", "body", *m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("progress"+"."+"percent_complete", "body", *m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunCopyDestinationsItems0ProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunCopyDestinationsItems0ProgressTypeStatePropEnum = append(lunCopyDestinationsItems0ProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePreparing captures enum value "preparing"
	LunCopyDestinationsItems0ProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateReplicating captures enum value "replicating"
	LunCopyDestinationsItems0ProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePaused captures enum value "paused"
	LunCopyDestinationsItems0ProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePausedError captures enum value "paused_error"
	LunCopyDestinationsItems0ProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateComplete captures enum value "complete"
	LunCopyDestinationsItems0ProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateReverting captures enum value "reverting"
	LunCopyDestinationsItems0ProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateFailed captures enum value "failed"
	LunCopyDestinationsItems0ProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunCopyDestinationsItems0Progress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunCopyDestinationsItems0ProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("progress"+"."+"state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 progress based on the context it is used
func (m *LunCopyDestinationsItems0Progress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"elapsed", "body", m.Elapsed); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"percent_complete", "body", m.PercentComplete); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Progress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Progress) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0Progress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineCopyInlineSource The source LUN of a LUN copy operation in which the containing LUN is the destination of the copy.<br/>
// Valid in POST except when creating a LUN clone. A LUN copy request cannot be combined with setting any other LUN properties except the destination location. All other properties of the destination LUN come from the source LUN.
//
// swagger:model lun_inline_copy_inline_source
type LunInlineCopyInlineSource struct {

	// links
	Links *LunInlineCopyInlineSourceInlineLinks `json:"_links,omitempty"`

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN copy. This property can be used to throttle a transfer and limit its impact on the performance of the source and destination nodes. The specified value will be rounded up to the nearest megabyte.<br/>
	// If this property is not specified in a POST that begins a LUN copy, throttling is not applied to the data transfer.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.<br/>
	// Valid only in a POST that begins a LUN copy or a PATCH when a LUN copy is already in process.
	//
	MaxThroughput *int64 `json:"max_throughput,omitempty"`

	// The fully qualified path of the LUN copy source composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.<br/>
	// Set this property in POST to specify the source for a LUN copy operation.
	//
	// Example: /vol/vol2/lun1
	Name *string `json:"name,omitempty"`

	// progress
	Progress *LunInlineCopyInlineSourceInlineProgress `json:"progress,omitempty"`

	// The unique identifier of the LUN copy source.<br/>
	// Set this property in POST to specify the source for a LUN copy operation.
	//
	// Example: 03c05019-40d9-3945-c767-dca4c3be5e90
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline copy inline source
func (m *LunInlineCopyInlineSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSource) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineCopyInlineSource) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline copy inline source based on the context it is used
func (m *LunInlineCopyInlineSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSource) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineCopyInlineSource) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineCopyInlineSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineCopyInlineSource) UnmarshalBinary(b []byte) error {
	var res LunInlineCopyInlineSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineCopyInlineSourceInlineLinks lun inline copy inline source inline links
//
// swagger:model lun_inline_copy_inline_source_inline__links
type LunInlineCopyInlineSourceInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline copy inline source inline links
func (m *LunInlineCopyInlineSourceInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSourceInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline copy inline source inline links based on the context it is used
func (m *LunInlineCopyInlineSourceInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSourceInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineCopyInlineSourceInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineCopyInlineSourceInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineCopyInlineSourceInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineCopyInlineSourceInlineProgress Properties related to the progress of an active or recently completed LUN copy.
//
// swagger:model lun_inline_copy_inline_source_inline_progress
type LunInlineCopyInlineSourceInlineProgress struct {

	// The amount of time that has elapsed since the start of the LUN copy, in seconds.
	//
	// Read Only: true
	Elapsed *int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN copy operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN copy.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete *int64 `json:"percent_complete,omitempty"`

	// The state of the LUN copy.<br/>
	// Valid in PATCH when an LUN copy is active. Set to _paused_ to pause a LUN copy. Set to _replicating_ to resume a paused LUN copy.
	//
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State *string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN copy. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN copy.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun inline copy inline source inline progress
func (m *LunInlineCopyInlineSourceInlineProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", *m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", *m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunInlineCopyInlineSourceInlineProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineCopyInlineSourceInlineProgressTypeStatePropEnum = append(lunInlineCopyInlineSourceInlineProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStatePreparing captures enum value "preparing"
	LunInlineCopyInlineSourceInlineProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStateReplicating captures enum value "replicating"
	LunInlineCopyInlineSourceInlineProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStatePaused captures enum value "paused"
	LunInlineCopyInlineSourceInlineProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStatePausedError captures enum value "paused_error"
	LunInlineCopyInlineSourceInlineProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStateComplete captures enum value "complete"
	LunInlineCopyInlineSourceInlineProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStateReverting captures enum value "reverting"
	LunInlineCopyInlineSourceInlineProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// lun_inline_copy_inline_source_inline_progress
	// LunInlineCopyInlineSourceInlineProgress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunInlineCopyInlineSourceInlineProgressStateFailed captures enum value "failed"
	LunInlineCopyInlineSourceInlineProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunInlineCopyInlineSourceInlineProgress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineCopyInlineSourceInlineProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("copy"+"."+"source"+"."+"progress"+"."+"state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline copy inline source inline progress based on the context it is used
func (m *LunInlineCopyInlineSourceInlineProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"elapsed", "body", m.Elapsed); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineCopyInlineSourceInlineProgress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineCopyInlineSourceInlineProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineCopyInlineSourceInlineProgress) UnmarshalBinary(b []byte) error {
	var res LunInlineCopyInlineSourceInlineProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLinks lun inline links
//
// swagger:model lun_inline__links
type LunInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline links
func (m *LunInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline links based on the context it is used
func (m *LunInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocation The location of the LUN within the ONTAP cluster. Valid in POST and PATCH.
//
// swagger:model lun_inline_location
type LunInlineLocation struct {

	// The base name component of the LUN. Valid in POST and PATCH.<br/>
	// If properties `name` and `location.logical_unit` are specified in the same request, they must refer to the base name.<br/>
	// A PATCH that modifies the base name of the LUN is considered a rename operation.
	//
	// Example: lun1
	LogicalUnit *string `json:"logical_unit,omitempty"`

	// node
	Node *LunInlineLocationInlineNode `json:"node,omitempty"`

	// qtree
	Qtree *LunInlineLocationInlineQtree `json:"qtree,omitempty"`

	// volume
	Volume *LunInlineLocationInlineVolume `json:"volume,omitempty"`
}

// Validate validates this lun inline location
func (m *LunInlineLocation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQtree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocation) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLocation) validateQtree(formats strfmt.Registry) error {
	if swag.IsZero(m.Qtree) { // not required
		return nil
	}

	if m.Qtree != nil {
		if err := m.Qtree.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLocation) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location based on the context it is used
func (m *LunInlineLocation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQtree(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocation) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLocation) contextValidateQtree(ctx context.Context, formats strfmt.Registry) error {

	if m.Qtree != nil {
		if err := m.Qtree.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLocation) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocation) UnmarshalBinary(b []byte) error {
	var res LunInlineLocation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineNode The cluster node that hosts the LUN.
//
// swagger:model lun_inline_location_inline_node
type LunInlineLocationInlineNode struct {

	// links
	Links *LunInlineLocationInlineNodeInlineLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name *string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline location inline node
func (m *LunInlineLocationInlineNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location inline node based on the context it is used
func (m *LunInlineLocationInlineNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineNode) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineNodeInlineLinks lun inline location inline node inline links
//
// swagger:model lun_inline_location_inline_node_inline__links
type LunInlineLocationInlineNodeInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline location inline node inline links
func (m *LunInlineLocationInlineNodeInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineNodeInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location inline node inline links based on the context it is used
func (m *LunInlineLocationInlineNodeInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineNodeInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineNodeInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineNodeInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineNodeInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineQtree The qtree in which the LUN is optionally located. Valid in POST and PATCH.<br/>
// If properties `name` and `location.qtree.name` and/or `location.qtree.uuid` are specified in the same request, they must refer to the same qtree.<br/>
// A PATCH that modifies the qtree of the LUN is considered a rename operation.
//
// swagger:model lun_inline_location_inline_qtree
type LunInlineLocationInlineQtree struct {

	// links
	Links *LunInlineLocationInlineQtreeInlineLinks `json:"_links,omitempty"`

	// The identifier for the qtree, unique within the qtree's volume.
	//
	// Example: 1
	// Maximum: 4994
	// Minimum: 0
	ID *int64 `json:"id,omitempty"`

	// The name of the qtree.
	// Example: qt1
	Name *string `json:"name,omitempty"`
}

// Validate validates this lun inline location inline qtree
func (m *LunInlineLocationInlineQtree) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineQtree) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLocationInlineQtree) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinimumInt("location"+"."+"qtree"+"."+"id", "body", *m.ID, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("location"+"."+"qtree"+"."+"id", "body", *m.ID, 4994, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline location inline qtree based on the context it is used
func (m *LunInlineLocationInlineQtree) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineQtree) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineQtree) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineQtree) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineQtree
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineQtreeInlineLinks lun inline location inline qtree inline links
//
// swagger:model lun_inline_location_inline_qtree_inline__links
type LunInlineLocationInlineQtreeInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline location inline qtree inline links
func (m *LunInlineLocationInlineQtreeInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineQtreeInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location inline qtree inline links based on the context it is used
func (m *LunInlineLocationInlineQtreeInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineQtreeInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineQtreeInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineQtreeInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineQtreeInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineVolume The volume in which the LUN is located. Valid in POST and PATCH.<br/>
// If properties `name` and `location.volume.name` and/or `location.volume.uuid` are specified in the same request, they must refer to the same volume.<br/>
// A PATCH that modifies the volume of the LUN begins an asynchronous LUN movement operation.
//
// swagger:model lun_inline_location_inline_volume
type LunInlineLocationInlineVolume struct {

	// links
	Links *LunInlineLocationInlineVolumeInlineLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name *string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline location inline volume
func (m *LunInlineLocationInlineVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location inline volume based on the context it is used
func (m *LunInlineLocationInlineVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineVolume) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLocationInlineVolumeInlineLinks lun inline location inline volume inline links
//
// swagger:model lun_inline_location_inline_volume_inline__links
type LunInlineLocationInlineVolumeInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline location inline volume inline links
func (m *LunInlineLocationInlineVolumeInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineVolumeInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline location inline volume inline links based on the context it is used
func (m *LunInlineLocationInlineVolumeInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLocationInlineVolumeInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLocationInlineVolumeInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLocationInlineVolumeInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLocationInlineVolumeInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLunMapsInlineArrayItem A LUN map with which the LUN is associated.
//
// swagger:model lun_inline_lun_maps_inline_array_item
type LunInlineLunMapsInlineArrayItem struct {

	// links
	Links *LunInlineLunMapsInlineArrayItemInlineLinks `json:"_links,omitempty"`

	// igroup
	Igroup *LunInlineLunMapsInlineArrayItemInlineIgroup `json:"igroup,omitempty"`

	// The logical unit number assigned to the LUN for initiators in the initiator group.
	//
	// Read Only: true
	LogicalUnitNumber *int64 `json:"logical_unit_number,omitempty"`
}

// Validate validates this lun inline lun maps inline array item
func (m *LunInlineLunMapsInlineArrayItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItem) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLunMapsInlineArrayItem) validateIgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroup) { // not required
		return nil
	}

	if m.Igroup != nil {
		if err := m.Igroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline lun maps inline array item based on the context it is used
func (m *LunInlineLunMapsInlineArrayItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalUnitNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItem) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLunMapsInlineArrayItem) contextValidateIgroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Igroup != nil {
		if err := m.Igroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLunMapsInlineArrayItem) contextValidateLogicalUnitNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "logical_unit_number", "body", m.LogicalUnitNumber); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItem) UnmarshalBinary(b []byte) error {
	var res LunInlineLunMapsInlineArrayItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLunMapsInlineArrayItemInlineIgroup The initiator group to which the LUN is mapped.
//
// swagger:model lun_inline_lun_maps_inline_array_item_inline_igroup
type LunInlineLunMapsInlineArrayItemInlineIgroup struct {

	// links
	Links *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks `json:"_links,omitempty"`

	// The name of the initiator group.
	//
	// Example: igroup1
	// Read Only: true
	Name *string `json:"name,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline lun maps inline array item inline igroup
func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline lun maps inline array item inline igroup based on the context it is used
func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineIgroup) UnmarshalBinary(b []byte) error {
	var res LunInlineLunMapsInlineArrayItemInlineIgroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks lun inline lun maps inline array item inline igroup inline links
//
// swagger:model lun_inline_lun_maps_inline_array_item_inline_igroup_inline__links
type LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline lun maps inline array item inline igroup inline links
func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline lun maps inline array item inline igroup inline links based on the context it is used
func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLunMapsInlineArrayItemInlineIgroupInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineLunMapsInlineArrayItemInlineLinks lun inline lun maps inline array item inline links
//
// swagger:model lun_inline_lun_maps_inline_array_item_inline__links
type LunInlineLunMapsInlineArrayItemInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline lun maps inline array item inline links
func (m *LunInlineLunMapsInlineArrayItemInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline lun maps inline array item inline links based on the context it is used
func (m *LunInlineLunMapsInlineArrayItemInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineLunMapsInlineArrayItemInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineLunMapsInlineArrayItemInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineLunMapsInlineArrayItemInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMetric lun inline metric
//
// swagger:model lun_inline_metric
type LunInlineMetric struct {

	// links
	Links *LunInlineMetricInlineLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration *string `json:"duration,omitempty"`

	// iops
	Iops *LunInlineMetricInlineIops `json:"iops,omitempty"`

	// latency
	Latency *LunInlineMetricInlineLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status *string `json:"status,omitempty"`

	// throughput
	Throughput *LunInlineMetricInlineThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this lun inline metric
func (m *LunInlineMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var lunInlineMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineMetricTypeDurationPropEnum = append(lunInlineMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// LunInlineMetricDurationPT15S captures enum value "PT15S"
	LunInlineMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// LunInlineMetricDurationPT4M captures enum value "PT4M"
	LunInlineMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// LunInlineMetricDurationPT30M captures enum value "PT30M"
	LunInlineMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// LunInlineMetricDurationPT2H captures enum value "PT2H"
	LunInlineMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// LunInlineMetricDurationP1D captures enum value "P1D"
	LunInlineMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// LunInlineMetricDurationPT5M captures enum value "PT5M"
	LunInlineMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *LunInlineMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", *m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var lunInlineMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineMetricTypeStatusPropEnum = append(lunInlineMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// LunInlineMetricStatusOk captures enum value "ok"
	LunInlineMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// LunInlineMetricStatusError captures enum value "error"
	LunInlineMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// LunInlineMetricStatusPartialNoData captures enum value "partial_no_data"
	LunInlineMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// LunInlineMetricStatusPartialNoResponse captures enum value "partial_no_response"
	LunInlineMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// LunInlineMetricStatusPartialOtherError captures enum value "partial_other_error"
	LunInlineMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// LunInlineMetricStatusNegativeDelta captures enum value "negative_delta"
	LunInlineMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// LunInlineMetricStatusNotFound captures enum value "not_found"
	LunInlineMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// LunInlineMetricStatusBackfilledData captures enum value "backfilled_data"
	LunInlineMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// LunInlineMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	LunInlineMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// LunInlineMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	LunInlineMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// lun_inline_metric
	// LunInlineMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// LunInlineMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	LunInlineMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *LunInlineMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline metric based on the context it is used
func (m *LunInlineMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMetric) UnmarshalBinary(b []byte) error {
	var res LunInlineMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMetricInlineIops The rate of I/O operations observed at the storage object.
//
// swagger:model lun_inline_metric_inline_iops
type LunInlineMetricInlineIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline metric inline iops
func (m *LunInlineMetricInlineIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline metric inline iops based on the context it is used
func (m *LunInlineMetricInlineIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMetricInlineIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMetricInlineIops) UnmarshalBinary(b []byte) error {
	var res LunInlineMetricInlineIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMetricInlineLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model lun_inline_metric_inline_latency
type LunInlineMetricInlineLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline metric inline latency
func (m *LunInlineMetricInlineLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline metric inline latency based on the context it is used
func (m *LunInlineMetricInlineLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMetricInlineLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMetricInlineLatency) UnmarshalBinary(b []byte) error {
	var res LunInlineMetricInlineLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMetricInlineLinks lun inline metric inline links
//
// swagger:model lun_inline_metric_inline__links
type LunInlineMetricInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline metric inline links
func (m *LunInlineMetricInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMetricInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline metric inline links based on the context it is used
func (m *LunInlineMetricInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMetricInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMetricInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMetricInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineMetricInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMetricInlineThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model lun_inline_metric_inline_throughput
type LunInlineMetricInlineThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline metric inline throughput
func (m *LunInlineMetricInlineThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline metric inline throughput based on the context it is used
func (m *LunInlineMetricInlineThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMetricInlineThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMetricInlineThroughput) UnmarshalBinary(b []byte) error {
	var res LunInlineMetricInlineThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMovement This sub-object applies to LUN movement between volumes. A LUN can be moved to a new volume with a PATCH request that changes either the volume portion of property `name`, `location.volume.uuid`, or `location.volume.name`. If the volume is changed using more than one of these properties, the supplied properties used must refer to the same volume.<br/>
// Moving a LUN between volumes is an asynchronous activity begun by a PATCH request. The data for the LUN is then asynchronously copied from the source volume to the destination volume. The time required to complete the move depends on the size of the LUN and the load on the cluster. The `movement` sub-object is populated while a LUN movement is in progress and for two (2) minutes following completion of a movement.<br/>
// While the LUN is being moved, the status of the LUN movement operation can be obtained using a GET for the LUN that requests the `movement` properties. The LUN movement operation can be further modified using a PATCH on the properties on the `movement` sub-object.<br/>
// There is an added computational cost to retrieving property values for `movement`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
// swagger:model lun_inline_movement
type LunInlineMovement struct {

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN movement. This property can be used to throttle a transfer and limit its impact on the performance of the source and destination nodes. The specified value will be rounded up to the nearest megabyte.<br/>
	// If this property is not specified in a POST that begins a LUN movement, throttling is not applied to the data transfer.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.<br/>
	// This property is valid only in a POST that begins a LUN movement or a PATCH when a LUN movement is already in process.
	//
	MaxThroughput *int64 `json:"max_throughput,omitempty"`

	// paths
	Paths *LunInlineMovementInlinePaths `json:"paths,omitempty"`

	// progress
	Progress *LunInlineMovementInlineProgress `json:"progress,omitempty"`
}

// Validate validates this lun inline movement
func (m *LunInlineMovement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePaths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMovement) validatePaths(formats strfmt.Registry) error {
	if swag.IsZero(m.Paths) { // not required
		return nil
	}

	if m.Paths != nil {
		if err := m.Paths.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "paths")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMovement) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline movement based on the context it is used
func (m *LunInlineMovement) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePaths(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMovement) contextValidatePaths(ctx context.Context, formats strfmt.Registry) error {

	if m.Paths != nil {
		if err := m.Paths.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "paths")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMovement) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMovement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMovement) UnmarshalBinary(b []byte) error {
	var res LunInlineMovement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMovementInlinePaths The fully qualified LUN path names involved in the LUN movement.
//
// swagger:model lun_inline_movement_inline_paths
type LunInlineMovementInlinePaths struct {

	// The fully qualified path of the LUN movement destination composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Destination *string `json:"destination,omitempty"`

	// The fully qualified path of the LUN movement source composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol2/lun2
	// Read Only: true
	Source *string `json:"source,omitempty"`
}

// Validate validates this lun inline movement inline paths
func (m *LunInlineMovementInlinePaths) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline movement inline paths based on the context it is used
func (m *LunInlineMovementInlinePaths) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMovementInlinePaths) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"paths"+"."+"destination", "body", m.Destination); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMovementInlinePaths) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"paths"+"."+"source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMovementInlinePaths) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMovementInlinePaths) UnmarshalBinary(b []byte) error {
	var res LunInlineMovementInlinePaths
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineMovementInlineProgress Properties related to the progress of an active or recently completed LUN movement.
//
// swagger:model lun_inline_movement_inline_progress
type LunInlineMovementInlineProgress struct {

	// The amount of time that has elapsed since the start of the LUN movement, in seconds.
	//
	// Read Only: true
	Elapsed *int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN movement operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN movement.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete *int64 `json:"percent_complete,omitempty"`

	// The state of the LUN movement.<br/>
	// Valid in PATCH when an LUN movement is active. Set to _paused_ to pause a LUN movement. Set to _replicating_ to resume a paused LUN movement.
	//
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State *string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN movement. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN movement.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun inline movement inline progress
func (m *LunInlineMovementInlineProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMovementInlineProgress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMovementInlineProgress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("movement"+"."+"progress"+"."+"percent_complete", "body", *m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("movement"+"."+"progress"+"."+"percent_complete", "body", *m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunInlineMovementInlineProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineMovementInlineProgressTypeStatePropEnum = append(lunInlineMovementInlineProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunInlineMovementInlineProgressStatePreparing captures enum value "preparing"
	LunInlineMovementInlineProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunInlineMovementInlineProgressStateReplicating captures enum value "replicating"
	LunInlineMovementInlineProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunInlineMovementInlineProgressStatePaused captures enum value "paused"
	LunInlineMovementInlineProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunInlineMovementInlineProgressStatePausedError captures enum value "paused_error"
	LunInlineMovementInlineProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunInlineMovementInlineProgressStateComplete captures enum value "complete"
	LunInlineMovementInlineProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunInlineMovementInlineProgressStateReverting captures enum value "reverting"
	LunInlineMovementInlineProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// lun_inline_movement_inline_progress
	// LunInlineMovementInlineProgress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunInlineMovementInlineProgressStateFailed captures enum value "failed"
	LunInlineMovementInlineProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunInlineMovementInlineProgress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineMovementInlineProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineMovementInlineProgress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("movement"+"."+"progress"+"."+"state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline movement inline progress based on the context it is used
func (m *LunInlineMovementInlineProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineMovementInlineProgress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"elapsed", "body", m.Elapsed); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMovementInlineProgress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineMovementInlineProgress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineMovementInlineProgress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineMovementInlineProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineMovementInlineProgress) UnmarshalBinary(b []byte) error {
	var res LunInlineMovementInlineProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineQosPolicy The QoS policy for the LUN. Both traditional and adaptive QoS policies are supported. If both property `qos_policy.uuid` and `qos_policy.name` are specified in the same request, they must refer to the same QoS policy. To remove the QoS policy from a LUN, leaving it with no QoS policy, set property `qos_policy.name` to an empty string ("") in a PATCH request. Valid in POST and PATCH.<br/>
// Note that a QoS policy can be set on a LUN, or a LUN's volume, but not both.
//
// swagger:model lun_inline_qos_policy
type LunInlineQosPolicy struct {

	// links
	Links *LunInlineQosPolicyInlineLinks `json:"_links,omitempty"`

	// The name of the QoS policy. To remove the QoS policy from a LUN, leaving it with no QoS policy, set this property to an empty string ("") in a PATCH request. Valid in POST and PATCH.
	//
	// Example: qos1
	Name *string `json:"name,omitempty"`

	// The unique identifier of the QoS policy. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline qos policy
func (m *LunInlineQosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineQosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline qos policy based on the context it is used
func (m *LunInlineQosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineQosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineQosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineQosPolicy) UnmarshalBinary(b []byte) error {
	var res LunInlineQosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineQosPolicyInlineLinks lun inline qos policy inline links
//
// swagger:model lun_inline_qos_policy_inline__links
type LunInlineQosPolicyInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline qos policy inline links
func (m *LunInlineQosPolicyInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineQosPolicyInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline qos policy inline links based on the context it is used
func (m *LunInlineQosPolicyInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineQosPolicyInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineQosPolicyInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineQosPolicyInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineQosPolicyInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineSpace The storage space related properties of the LUN.
//
// swagger:model lun_inline_space
type LunInlineSpace struct {

	// guarantee
	Guarantee *LunInlineSpaceInlineGuarantee `json:"guarantee,omitempty"`

	// To leverage the benefits of SCSI thin provisioning, it must be supported by your host. SCSI thin provisioning uses the Logical Block Provisioning feature as defined in the SCSI SBC-3 standard. Only hosts that support this standard can use SCSI thin provisioning in ONTAP.<br/>
	// When you enable SCSI thin provisioning support in ONTAP, you turn on the following SCSI thin provisioning features:
	// - Unmapping and reporting space usage for space reclamation
	// - Reporting resource exhaustion errors
	// <p/>
	// The value of this property is not propagated to the destination when a LUN is cloned as a new LUN or copied; it is reset to false. The value of this property is maintained from the destination LUN when a LUN is overwritten as a clone.<br/>
	// Valid in POST and PATCH.
	//
	ScsiThinProvisioningSupportEnabled *bool `json:"scsi_thin_provisioning_support_enabled,omitempty"`

	// The total provisioned size of the LUN. The LUN size can be increased but not be made smaller using the REST interface.<br/>
	// The maximum and minimum sizes listed here are the absolute maximum and absolute minimum sizes in bytes. The actual minimum and maxiumum sizes vary depending on the ONTAP version, ONTAP platform and the available space in the containing volume and aggregate.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Example: 1073741824
	// Maximum: 1.40737488355328e+14
	// Minimum: 4096
	Size *int64 `json:"size,omitempty"`

	// The amount of space consumed by the main data stream of the LUN.<br/>
	// This value is the total space consumed in the volume by the LUN, including filesystem overhead, but excluding prefix and suffix streams. Due to internal filesystem overhead and the many ways SAN filesystems and applications utilize blocks within a LUN, this value does not necessarily reflect actual consumption/availability from the perspective of the filesystem or application. Without specific knowledge of how the LUN blocks are utilized outside of ONTAP, this property should not be used as an indicator for an out-of-space condition.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Read Only: true
	Used *int64 `json:"used,omitempty"`
}

// Validate validates this lun inline space
func (m *LunInlineSpace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSpace) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineSpace) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := validate.MinimumInt("space"+"."+"size", "body", *m.Size, 4096, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("space"+"."+"size", "body", *m.Size, 1.40737488355328e+14, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline space based on the context it is used
func (m *LunInlineSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSpace) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", m.Used); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineSpace) UnmarshalBinary(b []byte) error {
	var res LunInlineSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineSpaceInlineGuarantee Properties that request and report the space guarantee for the LUN.
//
// swagger:model lun_inline_space_inline_guarantee
type LunInlineSpaceInlineGuarantee struct {

	// The requested space reservation policy for the LUN. If _true_, a space reservation is requested for the LUN; if _false_, the LUN is thin provisioned. Guaranteeing a space reservation request for a LUN requires that the volume in which the LUN resides is also space reserved and that the fractional reserve for the volume is 100%. Valid in POST and PATCH.
	//
	Requested *bool `json:"requested,omitempty"`

	// Reports if the LUN is space guaranteed.<br/>
	// If _true_, a space guarantee is requested and the containing volume and aggregate support the request. If _false_, a space guarantee is not requested or a space guarantee is requested and either the containing volume or aggregate do not support the request.
	//
	// Read Only: true
	Reserved *bool `json:"reserved,omitempty"`
}

// Validate validates this lun inline space inline guarantee
func (m *LunInlineSpaceInlineGuarantee) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline space inline guarantee based on the context it is used
func (m *LunInlineSpaceInlineGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReserved(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSpaceInlineGuarantee) contextValidateReserved(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"guarantee"+"."+"reserved", "body", m.Reserved); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineSpaceInlineGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineSpaceInlineGuarantee) UnmarshalBinary(b []byte) error {
	var res LunInlineSpaceInlineGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineStatistics lun inline statistics
//
// swagger:model lun_inline_statistics
type LunInlineStatistics struct {

	// iops raw
	IopsRaw *LunInlineStatisticsInlineIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *LunInlineStatisticsInlineLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status *string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *LunInlineStatisticsInlineThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this lun inline statistics
func (m *LunInlineStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var lunInlineStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineStatisticsTypeStatusPropEnum = append(lunInlineStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// LunInlineStatisticsStatusOk captures enum value "ok"
	LunInlineStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// LunInlineStatisticsStatusError captures enum value "error"
	LunInlineStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// LunInlineStatisticsStatusPartialNoData captures enum value "partial_no_data"
	LunInlineStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// LunInlineStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	LunInlineStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// LunInlineStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	LunInlineStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// LunInlineStatisticsStatusNegativeDelta captures enum value "negative_delta"
	LunInlineStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// LunInlineStatisticsStatusNotFound captures enum value "not_found"
	LunInlineStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// LunInlineStatisticsStatusBackfilledData captures enum value "backfilled_data"
	LunInlineStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// LunInlineStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	LunInlineStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// LunInlineStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	LunInlineStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// lun_inline_statistics
	// LunInlineStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// LunInlineStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	LunInlineStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *LunInlineStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline statistics based on the context it is used
func (m *LunInlineStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunInlineStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineStatistics) UnmarshalBinary(b []byte) error {
	var res LunInlineStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineStatisticsInlineIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model lun_inline_statistics_inline_iops_raw
type LunInlineStatisticsInlineIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline statistics inline iops raw
func (m *LunInlineStatisticsInlineIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline statistics inline iops raw based on the context it is used
func (m *LunInlineStatisticsInlineIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineStatisticsInlineIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineStatisticsInlineIopsRaw) UnmarshalBinary(b []byte) error {
	var res LunInlineStatisticsInlineIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineStatisticsInlineLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model lun_inline_statistics_inline_latency_raw
type LunInlineStatisticsInlineLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline statistics inline latency raw
func (m *LunInlineStatisticsInlineLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline statistics inline latency raw based on the context it is used
func (m *LunInlineStatisticsInlineLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineStatisticsInlineLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineStatisticsInlineLatencyRaw) UnmarshalBinary(b []byte) error {
	var res LunInlineStatisticsInlineLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineStatisticsInlineThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model lun_inline_statistics_inline_throughput_raw
type LunInlineStatisticsInlineThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other *int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read *int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total *int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write *int64 `json:"write,omitempty"`
}

// Validate validates this lun inline statistics inline throughput raw
func (m *LunInlineStatisticsInlineThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun inline statistics inline throughput raw based on the context it is used
func (m *LunInlineStatisticsInlineThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineStatisticsInlineThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineStatisticsInlineThroughputRaw) UnmarshalBinary(b []byte) error {
	var res LunInlineStatisticsInlineThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineStatus Status information about the LUN.
//
// swagger:model lun_inline_status
type LunInlineStatus struct {

	// The state of the volume and aggregate that contain the LUN. LUNs are only available when their containers are available.
	//
	// Read Only: true
	// Enum: [online aggregate_offline volume_offline]
	ContainerState *string `json:"container_state,omitempty"`

	// Reports if the LUN is mapped to one or more initiator groups.<br/>
	// There is an added computational cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	Mapped *bool `json:"mapped,omitempty"`

	// Reports if the LUN allows only read access.
	//
	// Read Only: true
	ReadOnly *bool `json:"read_only,omitempty"`

	// The state of the LUN. Normal states for a LUN are _online_ and _offline_. Other states indicate errors.
	//
	// Example: online
	// Read Only: true
	// Enum: [foreign_lun_error nvfail offline online space_error]
	State *string `json:"state,omitempty"`
}

// Validate validates this lun inline status
func (m *LunInlineStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContainerState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var lunInlineStatusTypeContainerStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","aggregate_offline","volume_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineStatusTypeContainerStatePropEnum = append(lunInlineStatusTypeContainerStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// container_state
	// ContainerState
	// online
	// END DEBUGGING
	// LunInlineStatusContainerStateOnline captures enum value "online"
	LunInlineStatusContainerStateOnline string = "online"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// container_state
	// ContainerState
	// aggregate_offline
	// END DEBUGGING
	// LunInlineStatusContainerStateAggregateOffline captures enum value "aggregate_offline"
	LunInlineStatusContainerStateAggregateOffline string = "aggregate_offline"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// container_state
	// ContainerState
	// volume_offline
	// END DEBUGGING
	// LunInlineStatusContainerStateVolumeOffline captures enum value "volume_offline"
	LunInlineStatusContainerStateVolumeOffline string = "volume_offline"
)

// prop value enum
func (m *LunInlineStatus) validateContainerStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineStatusTypeContainerStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineStatus) validateContainerState(formats strfmt.Registry) error {
	if swag.IsZero(m.ContainerState) { // not required
		return nil
	}

	// value enum
	if err := m.validateContainerStateEnum("status"+"."+"container_state", "body", *m.ContainerState); err != nil {
		return err
	}

	return nil
}

var lunInlineStatusTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["foreign_lun_error","nvfail","offline","online","space_error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunInlineStatusTypeStatePropEnum = append(lunInlineStatusTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// state
	// State
	// foreign_lun_error
	// END DEBUGGING
	// LunInlineStatusStateForeignLunError captures enum value "foreign_lun_error"
	LunInlineStatusStateForeignLunError string = "foreign_lun_error"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// state
	// State
	// nvfail
	// END DEBUGGING
	// LunInlineStatusStateNvfail captures enum value "nvfail"
	LunInlineStatusStateNvfail string = "nvfail"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// state
	// State
	// offline
	// END DEBUGGING
	// LunInlineStatusStateOffline captures enum value "offline"
	LunInlineStatusStateOffline string = "offline"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// state
	// State
	// online
	// END DEBUGGING
	// LunInlineStatusStateOnline captures enum value "online"
	LunInlineStatusStateOnline string = "online"

	// BEGIN DEBUGGING
	// lun_inline_status
	// LunInlineStatus
	// state
	// State
	// space_error
	// END DEBUGGING
	// LunInlineStatusStateSpaceError captures enum value "space_error"
	LunInlineStatusStateSpaceError string = "space_error"
)

// prop value enum
func (m *LunInlineStatus) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunInlineStatusTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunInlineStatus) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("status"+"."+"state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun inline status based on the context it is used
func (m *LunInlineStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContainerState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMapped(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReadOnly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineStatus) contextValidateContainerState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"container_state", "body", m.ContainerState); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineStatus) contextValidateMapped(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"mapped", "body", m.Mapped); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineStatus) contextValidateReadOnly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"read_only", "body", m.ReadOnly); err != nil {
		return err
	}

	return nil
}

func (m *LunInlineStatus) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineStatus) UnmarshalBinary(b []byte) error {
	var res LunInlineStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineSvm The SVM in which the LUN is located.
//
// swagger:model lun_inline_svm
type LunInlineSvm struct {

	// links
	Links *LunInlineSvmInlineLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name *string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun inline svm
func (m *LunInlineSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline svm based on the context it is used
func (m *LunInlineSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineSvm) UnmarshalBinary(b []byte) error {
	var res LunInlineSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineSvmInlineLinks lun inline svm inline links
//
// swagger:model lun_inline_svm_inline__links
type LunInlineSvmInlineLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun inline svm inline links
func (m *LunInlineSvmInlineLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSvmInlineLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun inline svm inline links based on the context it is used
func (m *LunInlineSvmInlineLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineSvmInlineLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineSvmInlineLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineSvmInlineLinks) UnmarshalBinary(b []byte) error {
	var res LunInlineSvmInlineLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunInlineVvol A VMware virtual volume (vVol) binding is an association between a LUN of class `protocol_endpoint` and a LUN of class `vvol`. Class `protocol_endpoint` LUNs are mapped to igroups and granted access using the same configuration as class `regular` LUNs. When a class `vvol` LUN is bound to a mapped class `protocol_endpoint` LUN, VMware can access the class `vvol` LUN through the class `protocol_endpoint` LUN mapping.</br>
// See [`POST /protocols/san/vvol-bindings`](#/SAN/vvol_binding_create) to learn more about creating vVol bindings and [`DELETE /protocols/san/vvol-bindings`](#/SAN/vvol_binding_delete) to learn more about deleting vVol bindings.</br>
// There is an added computational cost to retrieving property values for `vvol`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
// swagger:model lun_inline_vvol
type LunInlineVvol struct {

	// Bindings between the LUN, which must be of class `protocol_endpoint` or `vvol`, and LUNs of the opposite class.<br/>
	// A class `vvol` LUN must be bound to a class `protocol_endpoint` LUN in order to be accessed. Class `protocol_endpoint` and `vvol` LUNs allow many-to-many bindings. A LUN of one class is allowed to be bound to zero or more LUNs of the opposite class. The binding between any two specific LUNs is reference counted. When a binding is created that already exists, the binding count is incremented. When a binding is deleted, the binding count is decremented, but the LUNs remain bound if the resultant reference count is greater than zero. When the binding count reaches zero, the binding is destroyed.<br/>
	// The bindings array contains LUNs of the opposite class of the containing LUN object.<br/>
	// There is an added computational cost to retrieving property values for `vvol.bindings`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	Bindings []*LunVvolBindingsItems0 `json:"bindings,omitempty"`

	// Reports if the LUN is part of a VMware virtual volume (vVol) bind relationship. This is `true` if the LUN is of class `protocol_endpoint` or `vvol` and has one or more bindings to a LUN of the opposite class. This is false if the LUN is of class `regular` or unbound.
	//
	// Read Only: true
	IsBound *bool `json:"is_bound,omitempty"`
}

// Validate validates this lun inline vvol
func (m *LunInlineVvol) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineVvol) validateBindings(formats strfmt.Registry) error {
	if swag.IsZero(m.Bindings) { // not required
		return nil
	}

	for i := 0; i < len(m.Bindings); i++ {
		if swag.IsZero(m.Bindings[i]) { // not required
			continue
		}

		if m.Bindings[i] != nil {
			if err := m.Bindings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vvol" + "." + "bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this lun inline vvol based on the context it is used
func (m *LunInlineVvol) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBindings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsBound(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunInlineVvol) contextValidateBindings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vvol"+"."+"bindings", "body", []*LunVvolBindingsItems0(m.Bindings)); err != nil {
		return err
	}

	for i := 0; i < len(m.Bindings); i++ {

		if m.Bindings[i] != nil {
			if err := m.Bindings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vvol" + "." + "bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunInlineVvol) contextValidateIsBound(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vvol"+"."+"is_bound", "body", m.IsBound); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunInlineVvol) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunInlineVvol) UnmarshalBinary(b []byte) error {
	var res LunInlineVvol
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0 A vVol binding with which the LUN is associated.
//
// swagger:model LunVvolBindingsItems0
type LunVvolBindingsItems0 struct {

	// links
	Links *LunVvolBindingsItems0Links `json:"_links,omitempty"`

	// The identifier assigned to the binding. The bind identifier is unique amongst all class `vvol` LUNs bound to the same class `protocol_endpoint` LUN.
	//
	// Example: 1
	// Read Only: true
	ID *int64 `json:"id,omitempty"`

	// partner
	Partner *LunVvolBindingsItems0Partner `json:"partner,omitempty"`
}

// Validate validates this lun vvol bindings items0
func (m *LunVvolBindingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(m.Partner) { // not required
		return nil
	}

	if m.Partner != nil {
		if err := m.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 based on the context it is used
func (m *LunVvolBindingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *LunVvolBindingsItems0) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if m.Partner != nil {
		if err := m.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0Links lun vvol bindings items0 links
//
// swagger:model LunVvolBindingsItems0Links
type LunVvolBindingsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun vvol bindings items0 links
func (m *LunVvolBindingsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 links based on the context it is used
func (m *LunVvolBindingsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0Links) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0Partner The LUN partner that this LUN is bound to. If this LUN is a `vvol` class LUN, the partner is a `protocol_endpoint` class LUN.
//
// swagger:model LunVvolBindingsItems0Partner
type LunVvolBindingsItems0Partner struct {

	// links
	Links *LunVvolBindingsItems0PartnerLinks `json:"_links,omitempty"`

	// The name of the partner LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Name *string `json:"name,omitempty"`

	// The unique identifier of the partner LUN.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this lun vvol bindings items0 partner
func (m *LunVvolBindingsItems0Partner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Partner) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 partner based on the context it is used
func (m *LunVvolBindingsItems0Partner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0Partner) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0Partner) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0Partner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0PartnerLinks lun vvol bindings items0 partner links
//
// swagger:model LunVvolBindingsItems0PartnerLinks
type LunVvolBindingsItems0PartnerLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun vvol bindings items0 partner links
func (m *LunVvolBindingsItems0PartnerLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0PartnerLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 partner links based on the context it is used
func (m *LunVvolBindingsItems0PartnerLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0PartnerLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0PartnerLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0PartnerLinks) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0PartnerLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
