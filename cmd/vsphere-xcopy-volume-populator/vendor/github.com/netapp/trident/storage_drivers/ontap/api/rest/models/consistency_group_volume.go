// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ConsistencyGroupVolume consistency group volume
//
// swagger:model consistency_group_volume
type ConsistencyGroupVolume struct {

	// A comment for the volume. Valid in POST or PATCH.
	// Max Length: 1023
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.
	// Enum: [ar ar.utf_8 c c.utf_8 cs cs.utf_8 da da.utf_8 de de.utf_8 en en.utf_8 en_us en_us.utf_8 es es.utf_8 fi fi.utf_8 fr fr.utf_8 he he.utf_8 hr hr.utf_8 hu hu.utf_8 it it.utf_8 ja ja.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck ja_jp.pck.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ja_v1 ja_v1.utf_8 ko ko.utf_8 nl nl.utf_8 no no.utf_8 pl pl.utf_8 pt pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv sv.utf_8 tr tr.utf_8 utf8mb4 zh zh.gbk zh.gbk.utf_8 zh.utf_8 zh_tw zh_tw.big5 zh_tw.big5.utf_8 zh_tw.utf_8]
	Language *string `json:"language,omitempty"`

	// Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.
	// Example: vol_cs_dept
	// Max Length: 203
	// Min Length: 1
	Name *string `json:"name,omitempty"`

	// nas
	Nas *ConsistencyGroupVolumeInlineNas `json:"nas,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupVolumeInlineProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupVolumeInlineQos `json:"qos,omitempty"`

	// The Snapshot copy policy for this volume.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupVolumeInlineSpace `json:"space,omitempty"`

	// tiering
	Tiering *ConsistencyGroupVolumeInlineTiering `json:"tiering,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume
func (m *ConsistencyGroupVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolume) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 1023); err != nil {
		return err
	}

	return nil
}

var consistencyGroupVolumeTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","ar.utf_8","c","c.utf_8","cs","cs.utf_8","da","da.utf_8","de","de.utf_8","en","en.utf_8","en_us","en_us.utf_8","es","es.utf_8","fi","fi.utf_8","fr","fr.utf_8","he","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it","it.utf_8","ja","ja.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck","ja_jp.pck.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ja_v1","ja_v1.utf_8","ko","ko.utf_8","nl","nl.utf_8","no","no.utf_8","pl","pl.utf_8","pt","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv","sv.utf_8","tr","tr.utf_8","utf8mb4","zh","zh.gbk","zh.gbk.utf_8","zh.utf_8","zh_tw","zh_tw.big5","zh_tw.big5.utf_8","zh_tw.utf_8"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeTypeLanguagePropEnum = append(consistencyGroupVolumeTypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ar
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageAr captures enum value "ar"
	ConsistencyGroupVolumeLanguageAr string = "ar"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageArDotUTF8 captures enum value "ar.utf_8"
	ConsistencyGroupVolumeLanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// c
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageC captures enum value "c"
	ConsistencyGroupVolumeLanguageC string = "c"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCDotUTF8 captures enum value "c.utf_8"
	ConsistencyGroupVolumeLanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// cs
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCs captures enum value "cs"
	ConsistencyGroupVolumeLanguageCs string = "cs"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCsDotUTF8 captures enum value "cs.utf_8"
	ConsistencyGroupVolumeLanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// da
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDa captures enum value "da"
	ConsistencyGroupVolumeLanguageDa string = "da"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDaDotUTF8 captures enum value "da.utf_8"
	ConsistencyGroupVolumeLanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// de
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDe captures enum value "de"
	ConsistencyGroupVolumeLanguageDe string = "de"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDeDotUTF8 captures enum value "de.utf_8"
	ConsistencyGroupVolumeLanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEn captures enum value "en"
	ConsistencyGroupVolumeLanguageEn string = "en"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnDotUTF8 captures enum value "en.utf_8"
	ConsistencyGroupVolumeLanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en_us
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnUs captures enum value "en_us"
	ConsistencyGroupVolumeLanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	ConsistencyGroupVolumeLanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// es
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEs captures enum value "es"
	ConsistencyGroupVolumeLanguageEs string = "es"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEsDotUTF8 captures enum value "es.utf_8"
	ConsistencyGroupVolumeLanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fi
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFi captures enum value "fi"
	ConsistencyGroupVolumeLanguageFi string = "fi"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFiDotUTF8 captures enum value "fi.utf_8"
	ConsistencyGroupVolumeLanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFr captures enum value "fr"
	ConsistencyGroupVolumeLanguageFr string = "fr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFrDotUTF8 captures enum value "fr.utf_8"
	ConsistencyGroupVolumeLanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// he
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHe captures enum value "he"
	ConsistencyGroupVolumeLanguageHe string = "he"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHeDotUTF8 captures enum value "he.utf_8"
	ConsistencyGroupVolumeLanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHr captures enum value "hr"
	ConsistencyGroupVolumeLanguageHr string = "hr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHrDotUTF8 captures enum value "hr.utf_8"
	ConsistencyGroupVolumeLanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hu
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHu captures enum value "hu"
	ConsistencyGroupVolumeLanguageHu string = "hu"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHuDotUTF8 captures enum value "hu.utf_8"
	ConsistencyGroupVolumeLanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// it
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageIt captures enum value "it"
	ConsistencyGroupVolumeLanguageIt string = "it"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageItDotUTF8 captures enum value "it.utf_8"
	ConsistencyGroupVolumeLanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJa captures enum value "ja"
	ConsistencyGroupVolumeLanguageJa string = "ja"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaDotUTF8 captures enum value "ja.utf_8"
	ConsistencyGroupVolumeLanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDot932 captures enum value "ja_jp.932"
	ConsistencyGroupVolumeLanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPck captures enum value "ja_jp.pck"
	ConsistencyGroupVolumeLanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	ConsistencyGroupVolumeLanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaV1 captures enum value "ja_v1"
	ConsistencyGroupVolumeLanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	ConsistencyGroupVolumeLanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ko
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageKo captures enum value "ko"
	ConsistencyGroupVolumeLanguageKo string = "ko"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageKoDotUTF8 captures enum value "ko.utf_8"
	ConsistencyGroupVolumeLanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// nl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNl captures enum value "nl"
	ConsistencyGroupVolumeLanguageNl string = "nl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNlDotUTF8 captures enum value "nl.utf_8"
	ConsistencyGroupVolumeLanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// no
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNo captures enum value "no"
	ConsistencyGroupVolumeLanguageNo string = "no"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNoDotUTF8 captures enum value "no.utf_8"
	ConsistencyGroupVolumeLanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePl captures enum value "pl"
	ConsistencyGroupVolumeLanguagePl string = "pl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePlDotUTF8 captures enum value "pl.utf_8"
	ConsistencyGroupVolumeLanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pt
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePt captures enum value "pt"
	ConsistencyGroupVolumeLanguagePt string = "pt"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePtDotUTF8 captures enum value "pt.utf_8"
	ConsistencyGroupVolumeLanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ro
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRo captures enum value "ro"
	ConsistencyGroupVolumeLanguageRo string = "ro"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRoDotUTF8 captures enum value "ro.utf_8"
	ConsistencyGroupVolumeLanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ru
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRu captures enum value "ru"
	ConsistencyGroupVolumeLanguageRu string = "ru"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRuDotUTF8 captures enum value "ru.utf_8"
	ConsistencyGroupVolumeLanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sk
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSk captures enum value "sk"
	ConsistencyGroupVolumeLanguageSk string = "sk"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSkDotUTF8 captures enum value "sk.utf_8"
	ConsistencyGroupVolumeLanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSl captures enum value "sl"
	ConsistencyGroupVolumeLanguageSl string = "sl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSlDotUTF8 captures enum value "sl.utf_8"
	ConsistencyGroupVolumeLanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sv
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSv captures enum value "sv"
	ConsistencyGroupVolumeLanguageSv string = "sv"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSvDotUTF8 captures enum value "sv.utf_8"
	ConsistencyGroupVolumeLanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// tr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageTr captures enum value "tr"
	ConsistencyGroupVolumeLanguageTr string = "tr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageTrDotUTF8 captures enum value "tr.utf_8"
	ConsistencyGroupVolumeLanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageUtf8mb4 captures enum value "utf8mb4"
	ConsistencyGroupVolumeLanguageUtf8mb4 string = "utf8mb4"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZh captures enum value "zh"
	ConsistencyGroupVolumeLanguageZh string = "zh"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotGbk captures enum value "zh.gbk"
	ConsistencyGroupVolumeLanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	ConsistencyGroupVolumeLanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotUTF8 captures enum value "zh.utf_8"
	ConsistencyGroupVolumeLanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTw captures enum value "zh_tw"
	ConsistencyGroupVolumeLanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	ConsistencyGroupVolumeLanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	ConsistencyGroupVolumeLanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	ConsistencyGroupVolumeLanguageZhTwDotUTF8 string = "zh_tw.utf_8"
)

// prop value enum
func (m *ConsistencyGroupVolume) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolume) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", *m.Language); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateNas(formats strfmt.Registry) error {
	if swag.IsZero(m.Nas) { // not required
		return nil
	}

	if m.Nas != nil {
		if err := m.Nas.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume based on the context it is used
func (m *ConsistencyGroupVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolume) contextValidateNas(ctx context.Context, formats strfmt.Registry) error {

	if m.Nas != nil {
		if err := m.Nas.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolume) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineNas The CIFS share policy and/or export policies for this volume.
//
// swagger:model consistency_group_volume_inline_nas
type ConsistencyGroupVolumeInlineNas struct {

	// cifs
	Cifs *ConsistencyGroupVolumeInlineNasInlineCifs `json:"cifs,omitempty"`

	// export policy
	ExportPolicy *ConsistencyGroupVolumeInlineNasInlineExportPolicy `json:"export_policy,omitempty"`

	// The UNIX group ID of the volume. Valid in POST or PATCH.
	Gid *int64 `json:"gid,omitempty"`

	// junction parent
	JunctionParent *ConsistencyGroupVolumeInlineNasInlineJunctionParent `json:"junction_parent,omitempty"`

	// The fully-qualified path in the owning SVM's namespace at which the volume is mounted. The path is case insensitive and must be unique within an SVM's namespace. Path must begin with '/' and must not end with '/'. Only one volume can be mounted at any given junction path. An empty path in POST creates an unmounted volume. An empty path in PATCH deactivates and unmounts the volume. Taking a volume offline or restricted state removes its junction path. This attribute is reported in GET only when the volume is mounted.
	// Example: /user/my_volume
	Path *string `json:"path,omitempty"`

	// Security style associated with the volume. Valid in POST or PATCH.<br>mixed &dash; Mixed-style security<br>ntfs &dash; NTFS/WIndows-style security<br>unified &dash; Unified-style security, unified UNIX, NFS and CIFS permissions<br>unix &dash; UNIX-style security.
	// Enum: [mixed ntfs unified unix]
	SecurityStyle *string `json:"security_style,omitempty"`

	// The UNIX user ID of the volume. Valid in POST or PATCH.
	UID *int64 `json:"uid,omitempty"`

	// UNIX permissions to be viewed as an octal number, consisting of 4 digits derived by adding up bits 4 (read), 2 (write), and 1 (execute). First digit selects the set user ID (4), set group ID (2), and sticky (1) attributes. Second digit selects permission for the owner of the file. Third selects permissions for other users in the same group while the fourth selects permissions for other users not in the group. Valid in POST or PATCH. For security style "mixed" or "unix", the default setting is 0755 in octal (493 in decimal) and for security style "ntfs", the default setting is 0000. In cases where only owner, group, and other permissions are given (as in 755, representing the second, third and fourth digit), the first digit is assumed to be zero.
	// Example: 755
	UnixPermissions *int64 `json:"unix_permissions,omitempty"`
}

// Validate validates this consistency group volume inline nas
func (m *ConsistencyGroupVolumeInlineNas) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCifs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExportPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJunctionParent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityStyle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) validateCifs(formats strfmt.Registry) error {
	if swag.IsZero(m.Cifs) { // not required
		return nil
	}

	if m.Cifs != nil {
		if err := m.Cifs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "cifs")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) validateExportPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ExportPolicy) { // not required
		return nil
	}

	if m.ExportPolicy != nil {
		if err := m.ExportPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) validateJunctionParent(formats strfmt.Registry) error {
	if swag.IsZero(m.JunctionParent) { // not required
		return nil
	}

	if m.JunctionParent != nil {
		if err := m.JunctionParent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent")
			}
			return err
		}
	}

	return nil
}

var consistencyGroupVolumeInlineNasTypeSecurityStylePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["mixed","ntfs","unified","unix"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeInlineNasTypeSecurityStylePropEnum = append(consistencyGroupVolumeInlineNasTypeSecurityStylePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_nas
	// ConsistencyGroupVolumeInlineNas
	// security_style
	// SecurityStyle
	// mixed
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineNasSecurityStyleMixed captures enum value "mixed"
	ConsistencyGroupVolumeInlineNasSecurityStyleMixed string = "mixed"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_nas
	// ConsistencyGroupVolumeInlineNas
	// security_style
	// SecurityStyle
	// ntfs
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineNasSecurityStyleNtfs captures enum value "ntfs"
	ConsistencyGroupVolumeInlineNasSecurityStyleNtfs string = "ntfs"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_nas
	// ConsistencyGroupVolumeInlineNas
	// security_style
	// SecurityStyle
	// unified
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineNasSecurityStyleUnified captures enum value "unified"
	ConsistencyGroupVolumeInlineNasSecurityStyleUnified string = "unified"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_nas
	// ConsistencyGroupVolumeInlineNas
	// security_style
	// SecurityStyle
	// unix
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineNasSecurityStyleUnix captures enum value "unix"
	ConsistencyGroupVolumeInlineNasSecurityStyleUnix string = "unix"
)

// prop value enum
func (m *ConsistencyGroupVolumeInlineNas) validateSecurityStyleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeInlineNasTypeSecurityStylePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) validateSecurityStyle(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityStyle) { // not required
		return nil
	}

	// value enum
	if err := m.validateSecurityStyleEnum("nas"+"."+"security_style", "body", *m.SecurityStyle); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group volume inline nas based on the context it is used
func (m *ConsistencyGroupVolumeInlineNas) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCifs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExportPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJunctionParent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) contextValidateCifs(ctx context.Context, formats strfmt.Registry) error {

	if m.Cifs != nil {
		if err := m.Cifs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "cifs")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) contextValidateExportPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ExportPolicy != nil {
		if err := m.ExportPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNas) contextValidateJunctionParent(ctx context.Context, formats strfmt.Registry) error {

	if m.JunctionParent != nil {
		if err := m.JunctionParent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNas) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNas) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineNas
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineNasInlineCifs consistency group volume inline nas inline cifs
//
// swagger:model consistency_group_volume_inline_nas_inline_cifs
type ConsistencyGroupVolumeInlineNasInlineCifs struct {

	// shares
	Shares []*ConsistencyGroupCifsShare `json:"shares,omitempty"`
}

// Validate validates this consistency group volume inline nas inline cifs
func (m *ConsistencyGroupVolumeInlineNasInlineCifs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateShares(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineCifs) validateShares(formats strfmt.Registry) error {
	if swag.IsZero(m.Shares) { // not required
		return nil
	}

	for i := 0; i < len(m.Shares); i++ {
		if swag.IsZero(m.Shares[i]) { // not required
			continue
		}

		if m.Shares[i] != nil {
			if err := m.Shares[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nas" + "." + "cifs" + "." + "shares" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group volume inline nas inline cifs based on the context it is used
func (m *ConsistencyGroupVolumeInlineNasInlineCifs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateShares(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineCifs) contextValidateShares(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Shares); i++ {

		if m.Shares[i] != nil {
			if err := m.Shares[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nas" + "." + "cifs" + "." + "shares" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineCifs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineCifs) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineNasInlineCifs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineNasInlineExportPolicy The policy associated with volumes to export them for protocol access.
//
// swagger:model consistency_group_volume_inline_nas_inline_export_policy
type ConsistencyGroupVolumeInlineNasInlineExportPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Name of the export policy.
	Name *string `json:"name,omitempty"`

	// The set of rules that govern the export policy.
	Rules []*ExportRules `json:"rules,omitempty"`

	// Identifier for the export policy.
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume inline nas inline export policy
func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(m.Rules) { // not required
		return nil
	}

	for i := 0; i < len(m.Rules); i++ {
		if swag.IsZero(m.Rules[i]) { // not required
			continue
		}

		if m.Rules[i] != nil {
			if err := m.Rules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nas" + "." + "export_policy" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group volume inline nas inline export policy based on the context it is used
func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Rules); i++ {

		if m.Rules[i] != nil {
			if err := m.Rules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nas" + "." + "export_policy" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nas"+"."+"export_policy"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineExportPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineNasInlineExportPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineNasInlineJunctionParent consistency group volume inline nas inline junction parent
//
// swagger:model consistency_group_volume_inline_nas_inline_junction_parent
type ConsistencyGroupVolumeInlineNasInlineJunctionParent struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The name of the parent volume that contains the junction inode of this volume. The junction parent volume must belong to the same SVM that owns this volume.
	// Example: vs1_root
	Name *string `json:"name,omitempty"`

	// Unique identifier for the parent volume.
	// Example: 75c9cfb0-3eb4-11eb-9fb4-005056bb088a
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume inline nas inline junction parent
func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume inline nas inline junction parent based on the context it is used
func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineNasInlineJunctionParent) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineNasInlineJunctionParent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineProvisioningOptions Options that are applied to the operation.
//
// swagger:model consistency_group_volume_inline_provisioning_options
type ConsistencyGroupVolumeInlineProvisioningOptions struct {

	// Operation to perform
	// Enum: [create add remove]
	Action *string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count *int64 `json:"count,omitempty"`

	// storage service
	StorageService *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService `json:"storage_service,omitempty"`
}

// Validate validates this consistency group volume inline provisioning options
func (m *ConsistencyGroupVolumeInlineProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeInlineProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create","add","remove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeInlineProvisioningOptionsTypeActionPropEnum = append(consistencyGroupVolumeInlineProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options
	// ConsistencyGroupVolumeInlineProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupVolumeInlineProvisioningOptionsActionCreate string = "create"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options
	// ConsistencyGroupVolumeInlineProvisioningOptions
	// action
	// Action
	// add
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsActionAdd captures enum value "add"
	ConsistencyGroupVolumeInlineProvisioningOptionsActionAdd string = "add"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options
	// ConsistencyGroupVolumeInlineProvisioningOptions
	// action
	// Action
	// remove
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsActionRemove captures enum value "remove"
	ConsistencyGroupVolumeInlineProvisioningOptionsActionRemove string = "remove"
)

// prop value enum
func (m *ConsistencyGroupVolumeInlineProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeInlineProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", *m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineProvisioningOptions) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume inline provisioning options based on the context it is used
func (m *ConsistencyGroupVolumeInlineProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineProvisioningOptions) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService Determines the placement of any storage object created during this operation.
//
// swagger:model consistency_group_volume_inline_provisioning_options_inline_storage_service
type ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name *string `json:"name,omitempty"`
}

// Validate validates this consistency group volume inline provisioning options inline storage service
func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceTypeNamePropEnum = append(consistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options_inline_storage_service
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNameExtreme captures enum value "extreme"
	ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options_inline_storage_service
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNamePerformance captures enum value "performance"
	ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_provisioning_options_inline_storage_service
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNameValue captures enum value "value"
	ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeInlineProvisioningOptionsInlineStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group volume inline provisioning options inline storage service based on context it is used
func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineProvisioningOptionsInlineStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineQos The QoS policy for this volume.
//
// swagger:model consistency_group_volume_inline_qos
type ConsistencyGroupVolumeInlineQos struct {

	// policy
	Policy *ConsistencyGroupVolumeInlineQosInlinePolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group volume inline qos
func (m *ConsistencyGroupVolumeInlineQos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineQos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume inline qos based on the context it is used
func (m *ConsistencyGroupVolumeInlineQos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineQos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineQos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineQos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineQos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineQosInlinePolicy The QoS policy
//
// swagger:model consistency_group_volume_inline_qos_inline_policy
type ConsistencyGroupVolumeInlineQosInlinePolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops *int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps *int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops *int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps *int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name *string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID *string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume inline qos inline policy
func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume inline qos inline policy based on the context it is used
func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineQosInlinePolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineQosInlinePolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineSpace consistency group volume inline space
//
// swagger:model consistency_group_volume_inline_space
type ConsistencyGroupVolumeInlineSpace struct {

	// The available space, in bytes.
	Available *int64 `json:"available,omitempty"`

	// Total provisioned size, in bytes.
	Size *int64 `json:"size,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	Used *int64 `json:"used,omitempty"`
}

// Validate validates this consistency group volume inline space
func (m *ConsistencyGroupVolumeInlineSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group volume inline space based on context it is used
func (m *ConsistencyGroupVolumeInlineSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineSpace) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeInlineTiering The tiering placement and policy definitions for this volume.
//
// swagger:model consistency_group_volume_inline_tiering
type ConsistencyGroupVolumeInlineTiering struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control *string `json:"control,omitempty"`

	// Object stores to use. Used for placement.
	//
	// Max Items: 2
	// Min Items: 0
	ObjectStores []*ConsistencyGroupVolumeTieringObjectStoresItems0 `json:"object_stores,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy *string `json:"policy,omitempty"`
}

// Validate validates this consistency group volume inline tiering
func (m *ConsistencyGroupVolumeInlineTiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectStores(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeInlineTieringTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeInlineTieringTypeControlPropEnum = append(consistencyGroupVolumeInlineTieringTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringControlAllowed captures enum value "allowed"
	ConsistencyGroupVolumeInlineTieringControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringControlBestEffort captures enum value "best_effort"
	ConsistencyGroupVolumeInlineTieringControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringControlDisallowed captures enum value "disallowed"
	ConsistencyGroupVolumeInlineTieringControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringControlRequired captures enum value "required"
	ConsistencyGroupVolumeInlineTieringControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupVolumeInlineTiering) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeInlineTieringTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineTiering) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", *m.Control); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumeInlineTiering) validateObjectStores(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectStores) { // not required
		return nil
	}

	iObjectStoresSize := int64(len(m.ObjectStores))

	if err := validate.MinItems("tiering"+"."+"object_stores", "body", iObjectStoresSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("tiering"+"."+"object_stores", "body", iObjectStoresSize, 2); err != nil {
		return err
	}

	for i := 0; i < len(m.ObjectStores); i++ {
		if swag.IsZero(m.ObjectStores[i]) { // not required
			continue
		}

		if m.ObjectStores[i] != nil {
			if err := m.ObjectStores[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tiering" + "." + "object_stores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var consistencyGroupVolumeInlineTieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeInlineTieringTypePolicyPropEnum = append(consistencyGroupVolumeInlineTieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringPolicyAll captures enum value "all"
	ConsistencyGroupVolumeInlineTieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringPolicyAuto captures enum value "auto"
	ConsistencyGroupVolumeInlineTieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringPolicyBackup captures enum value "backup"
	ConsistencyGroupVolumeInlineTieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringPolicyNone captures enum value "none"
	ConsistencyGroupVolumeInlineTieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// consistency_group_volume_inline_tiering
	// ConsistencyGroupVolumeInlineTiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupVolumeInlineTieringPolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupVolumeInlineTieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupVolumeInlineTiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeInlineTieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineTiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", *m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group volume inline tiering based on the context it is used
func (m *ConsistencyGroupVolumeInlineTiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjectStores(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeInlineTiering) contextValidateObjectStores(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ObjectStores); i++ {

		if m.ObjectStores[i] != nil {
			if err := m.ObjectStores[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tiering" + "." + "object_stores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineTiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeInlineTiering) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeInlineTiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeTieringObjectStoresItems0 consistency group volume tiering object stores items0
//
// swagger:model ConsistencyGroupVolumeTieringObjectStoresItems0
type ConsistencyGroupVolumeTieringObjectStoresItems0 struct {

	// The name of the object store to use. Used for placement.
	Name *string `json:"name,omitempty"`
}

// Validate validates this consistency group volume tiering object stores items0
func (m *ConsistencyGroupVolumeTieringObjectStoresItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group volume tiering object stores items0 based on context it is used
func (m *ConsistencyGroupVolumeTieringObjectStoresItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeTieringObjectStoresItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeTieringObjectStoresItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeTieringObjectStoresItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
