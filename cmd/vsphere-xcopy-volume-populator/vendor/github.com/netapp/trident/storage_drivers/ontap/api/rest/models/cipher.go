// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// Cipher Cipher for encrypting the data.
// Example: aes256_ctr
//
// swagger:model cipher
type Cipher string

func NewCipher(value Cipher) *Cipher {
	return &value
}

// Pointer returns a pointer to a freshly-allocated Cipher.
func (m Cipher) Pointer() *Cipher {
	return &m
}

const (

	// CipherAes256Ctr captures enum value "aes256_ctr"
	CipherAes256Ctr Cipher = "aes256_ctr"

	// CipherAes192Ctr captures enum value "aes192_ctr"
	CipherAes192Ctr Cipher = "aes192_ctr"

	// CipherAes128Ctr captures enum value "aes128_ctr"
	CipherAes128Ctr Cipher = "aes128_ctr"

	// CipherAes256Cbc captures enum value "aes256_cbc"
	CipherAes256Cbc Cipher = "aes256_cbc"

	// CipherAes192Cbc captures enum value "aes192_cbc"
	CipherAes192Cbc Cipher = "aes192_cbc"

	// CipherAes128Cbc captures enum value "aes128_cbc"
	CipherAes128Cbc Cipher = "aes128_cbc"

	// CipherNr3desCbc captures enum value "3des_cbc"
	CipherNr3desCbc Cipher = "3des_cbc"

	// CipherAes128Gcm captures enum value "aes128_gcm"
	CipherAes128Gcm Cipher = "aes128_gcm"

	// CipherAes256Gcm captures enum value "aes256_gcm"
	CipherAes256Gcm Cipher = "aes256_gcm"
)

// for schema
var cipherEnum []interface{}

func init() {
	var res []Cipher
	if err := json.Unmarshal([]byte(`["aes256_ctr","aes192_ctr","aes128_ctr","aes256_cbc","aes192_cbc","aes128_cbc","3des_cbc","aes128_gcm","aes256_gcm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cipherEnum = append(cipherEnum, v)
	}
}

func (m Cipher) validateCipherEnum(path, location string, value Cipher) error {
	if err := validate.EnumCase(path, location, value, cipherEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this cipher
func (m Cipher) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateCipherEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this cipher based on context it is used
func (m Cipher) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
